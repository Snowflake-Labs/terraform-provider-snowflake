# Run secret-dependent integration tests only after /ok-to-test approval
on:
  repository_dispatch:
    types: [ok-to-test-command]
  pull_request:
name: tests

jobs:
  all-tests:
    env:
      TEST_SF_TF_TEST_OBJECT_SUFFIX: ${{ (github.event_name == 'repository_dispatch' && github.event.client_payload.pull_request.head.sha) || (github.event_name == 'pull_request' && github.event.pull_request.head.sha) }}
    name: all-tests
    runs-on: ubuntu-latest
    if: (github.event_name == 'repository_dispatch') || (github.event_name == 'pull_request' && github.event.pull_request.head.repo.full_name == github.repository)
    steps:
      - id: verify_sha_input
        if: github.event_name == 'repository_dispatch'
        run: |
          echo \"${{ github.event.client_payload.pull_request.head.sha }}\"
          echo \"${{ github.event.client_payload.slash_command.args.named.sha }}\"
          SHAINPUT=$(echo ${{github.event.client_payload.slash_command.args.named.sha}} | cut -c1-7)
          if [ ${#SHAINPUT} -le 6 ]; then echo "error::input sha not at least 7 characters long" ; exit 1
          else echo "done"
          fi
          SHAHEAD=$(echo ${{github.event.client_payload.pull_request.head.sha}} | cut -c1-7)
          echo ${#SHAINPUT}
          echo ${#SHAHEAD}
          if [ "${SHAHEAD}" != "${SHAINPUT}" ]; then echo "sha input from slash command does not equal the head sha" ; exit 1
          else echo "shas are equal"
          fi

      - uses: actions/checkout@v3

      - uses: actions/setup-go@v4
        with:
          go-version-file: ./go.mod
          cache: false

      - name: GH Actions env
        run: echo "$GITHUB_ACTIONS"

      - name: Experiment with case
        run: echo "::add-mask::cAsE dOeS nOt MaTtEr"

      - name: Echo different case
        run: |
          echo "cAsE dOeS nOt MaTtEr"
          echo "CASE DOES NOT MATTER"
          echo "case does not matter"

      - name: Experiment single line env
        run: echo "::add-mask::$TEST_SF_TF_ONE_LINER"
        env:
          TEST_SF_TF_ONE_LINER: ${{ secrets.TEST_SF_TF_ONE_LINER }}

      - name: Experiment multiple lines env
        run: echo "::add-mask::$TEST_SF_TF_MULTI_LINER"
        env:
          TEST_SF_TF_MULTI_LINER: ${{ secrets.TEST_SF_TF_MULTI_LINER }}

      - name: Experiment all lines from env
        run: |
          while IFS= read -r line || [[ -n $line ]]; do
            echo "masking $line"
            echo "::add-mask::$line"
          done < <(printf '%s' "$TEST_SF_TF_ALL_LINES")
        env:
          TEST_SF_TF_ALL_LINES: ${{ secrets.TEST_SF_TF_ALL_LINES }}

      - name: Echo single line env content
        run: |
          echo "very secret info"
          echo "$TEST_SF_TF_ONE_LINER"
        env:
          TEST_SF_TF_ONE_LINER: ${{ secrets.TEST_SF_TF_ONE_LINER }}

      - name: Echo multiple lines env content
        run: |
          echo "masking does not\nwork this way.\n!@#$%^&*()_+=-1234567890"
          echo "$TEST_SF_TF_MULTI_LINER"
          echo "masking does not"
        env:
          TEST_SF_TF_MULTI_LINER: ${{ secrets.TEST_SF_TF_MULTI_LINER }}

      - name: Echo different lines from all lines env
        run: |
          echo "different space-separated"
          echo "really, really, really"
          echo "secret infos"
          echo "different space-separated really, really, really secret infos"
          echo "really, really,"
          echo "different"
          echo "infos"
          echo "$TEST_SF_TF_ALL_LINES"
        env:
          TEST_SF_TF_ALL_LINES: ${{ secrets.TEST_SF_TF_ALL_LINES }}

      - name: Install dependencies
        run: make dev-setup

      - run: make test-experiment
        env:
          TEST_SF_TF_ONE_LINER: ${{ secrets.TEST_SF_TF_ONE_LINER }}
          TEST_SF_TF_MULTI_LINER: ${{ secrets.TEST_SF_TF_MULTI_LINER }}
          TEST_SF_TF_ALL_LINES: ${{ secrets.TEST_SF_TF_ALL_LINES }}

      - name: find comment
        if: ${{ always() }}
        uses: peter-evans/find-comment@v2
        id: fc
        with:
          issue-number: ${{ github.event.pull_request.number || github.event.client_payload.pull_request.number }}
          comment-author: 'github-actions[bot]'
          body-includes: Integration tests ran for

      - name: create or update comment
        if: ${{ always() }}
        uses: peter-evans/create-or-update-comment@v2
        with:
          issue-number: ${{ github.event.pull_request.number || github.event.client_payload.pull_request.number }}
          comment-id: ${{ steps.fc.outputs.comment-id }}
          body: |
            Integration tests ${{ job.status }} for [${{ github.event.client_payload.slash_command.args.named.sha || github.event.pull_request.head.sha }}](https://github.com/Snowflake-Labs/terraform-provider-snowflake/actions/runs/${{ github.run_id }})

      - name: set fork job status
        uses: actions/github-script@v6
        if: ${{ always() }}
        id: update_check_run
        env:
          number: ${{ github.event.client_payload.pull_request.number }}
          job: ${{ github.job }}
          # Conveniently, job.status maps to https://developer.github.com/v3/checks/runs/#update-a-check-run
          conclusion: ${{ job.status }}
          sha: ${{ github.event.client_payload.slash_command.args.named.sha }}
          event_name: ${{ github.event_name }}
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            if (process.env.event_name !== 'repository_dispatch') {
              console.log("Not repository_dispatch... nothing to do!");
              return process.env.event_name;
            }
            const ref = process.env.sha;
            const { data: checks } = await github.rest.checks.listForRef({
              ...context.repo,
              ref
            });
            const check = checks.check_runs.filter(c => c.name === process.env.job);
            console.log(check);
            const { data: result } = await github.rest.checks.update({
              ...context.repo,
              check_run_id: check[0].id,
              status: 'completed',
              conclusion: process.env.conclusion
            });
            return result;
