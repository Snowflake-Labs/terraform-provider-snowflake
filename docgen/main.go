package main

import (
	"fmt"
	"log"
	"os"
	"path"
	"sort"
	"strings"

	"github.com/chanzuckerberg/terraform-provider-snowflake/pkg/provider"
	"github.com/hashicorp/terraform-plugin-sdk/helper/schema"
	"github.com/olekukonko/tablewriter"
)

func main() {
	docsPath := "docs/resources"

	resources := provider.Provider().ResourcesMap

	for name, resource := range resources {
		shortName := strings.TrimPrefix(name, "snowflake_")

		f, err := os.Create(path.Join(docsPath, fmt.Sprintf("%s.md", shortName)))
		if err != nil {
			log.Fatal(err)
		}

		_, err = f.WriteString(fmt.Sprintf("\n# %s\n\n", name))
		if err != nil {
			log.Fatalf("unable to write doc file %#v", err)
		}

		_, err = f.WriteString("<!-- These docs are auto-generated by code in ./docgen, run by with make docs. Manual edits will be overwritten. -->\n\n")
		if err != nil {
			log.Fatalf("unable to write doc file %#v", err)
		}

		if strings.HasSuffix(name, "_grant") {
			grant_resource_name := strings.Replace(name, "_grant", "", -1)
			granted_to_name := strings.Replace(grant_resource_name, "snowflake_", "", -1)
			_, err := f.WriteString(fmt.Sprintf(
				`**Note**: The %s resource creates exclusive attachments of grants.
		Across the entire Snowflake account, all of the %ss to which a single grant is attached must be declared
		by a single %s resource. This means that even any %s that have the attached
		grant via any other mechanism (including other Terraform resources) will have that attached grant revoked by this resource.
		These resources do not enforce exclusive attachment of a grant, it is the user's responsibility to enforce this.
		`, name, granted_to_name, name, grant_resource_name))
			if err != nil {
				log.Fatalf("unable to write doc file %#v", err)
			}
			_, err = f.WriteString("\n")
			if err != nil {
				log.Fatalf("unable to write doc file %#v", err)
			}
		}
		_, err = f.WriteString("## properties\n\n")
		if err != nil {
			log.Fatalf("unable to write doc file %#v", err)
		}

		table := tablewriter.NewWriter(f)
		table.SetAutoWrapText(false)
		table.SetHeader([]string{"name", "type", "description", "optional", " required", "computed", "default"})
		table.SetBorders(tablewriter.Border{Left: true, Top: false, Right: true, Bottom: false})
		table.SetCenterSeparator("|")

		properties := make([]string, 0)
		for k := range resource.Schema {
			properties = append(properties, k)
		}
		sort.Strings(properties)
		for _, property := range properties {
			s := resource.Schema[property]
			table.Append([]string{property, typeString(s.Type), s.Description, boolString(s.Optional), boolString(s.Required), boolString(s.Computed), interfaceString(s.Default)})
		}
		table.Render()
		f.Close()
	}
}

func typeString(t schema.ValueType) string {
	switch t {
	case schema.TypeBool:
		return "bool"
	case schema.TypeInt:
		return "int"
	case schema.TypeFloat:
		return "float"
	case schema.TypeString:
		return "string"
	case schema.TypeList:
		return "list"
	case schema.TypeMap:
		return "map"
	case schema.TypeSet:
		return "set"
	}
	return "?"
}

func boolString(t bool) string {
	return fmt.Sprintf("%t", t)
}

func interfaceString(t interface{}) string {
	if t == nil {
		return ""
	}
	return fmt.Sprintf("%#v", t)
}
