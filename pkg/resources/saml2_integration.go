package resources

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"
	"strings"

	"github.com/Snowflake-Labs/terraform-provider-snowflake/pkg/helpers"
	"github.com/Snowflake-Labs/terraform-provider-snowflake/pkg/internal/provider"
	"github.com/Snowflake-Labs/terraform-provider-snowflake/pkg/sdk"

	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/customdiff"
	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
)

var saml2IntegrationSchema = map[string]*schema.Schema{
	"name": {
		Type:        schema.TypeString,
		Required:    true,
		ForceNew:    true,
		Description: "Specifies the name of the SAML2 integration. This name follows the rules for Object Identifiers. The name should be unique among security integrations in your account.",
	},
	"enabled": {
		Type:        schema.TypeBool,
		Optional:    true,
		Description: "Specifies whether this security integration is enabled or disabled.",
	},
	"saml2_issuer": {
		Type:        schema.TypeString,
		Required:    true,
		Description: "The string containing the IdP EntityID / Issuer.",
	},
	"saml2_sso_url": {
		Type:        schema.TypeString,
		Required:    true,
		Description: "The string containing the IdP SSO URL, where the user should be redirected by Snowflake (the Service Provider) with a SAML AuthnRequest message.",
	},
	"saml2_provider": {
		Type:             schema.TypeString,
		Required:         true,
		Description:      fmt.Sprintf("The string describing the IdP. Valid options are: %v.", sdk.AllSaml2SecurityIntegrationSaml2Providers),
		ValidateDiagFunc: sdkValidation(sdk.ToSaml2SecurityIntegrationSaml2ProviderOption),
		DiffSuppressFunc: func(k, old, new string, d *schema.ResourceData) bool {
			normalize := func(s string) string {
				return strings.ToUpper(strings.ReplaceAll(s, "-", ""))
			}
			return normalize(old) == normalize(new)
		},
	},
	"saml2_x509_cert": {
		Type:        schema.TypeString,
		Required:    true,
		Description: "The Base64 encoded IdP signing certificate on a single line without the leading -----BEGIN CERTIFICATE----- and ending -----END CERTIFICATE----- markers.",
	},
	"saml2_sp_initiated_login_page_label": {
		Type:        schema.TypeString,
		Optional:    true,
		Description: "The string containing the label to display after the Log In With button on the login page.  If this field changes value from non-empty to empty, the whole resource is recreated because of Snowflake limitations.",
	},
	"saml2_enable_sp_initiated": {
		Type:        schema.TypeBool,
		Optional:    true,
		Description: "The Boolean indicating if the Log In With button will be shown on the login page. TRUE: displays the Log in With button on the login page. FALSE: does not display the Log in With button on the login page.",
	},
	"saml2_snowflake_x509_cert": {
		Type:        schema.TypeString,
		Optional:    true,
		Computed:    true,
		Description: "The Base64 encoded self-signed certificate generated by Snowflake for use with Encrypting SAML Assertions and Signed SAML Requests. You must have at least one of these features (encrypted SAML assertions or signed SAML responses) enabled in your Snowflake account to access the certificate value.",
	},
	"saml2_sign_request": {
		Type:        schema.TypeBool,
		Optional:    true,
		Description: "The Boolean indicating whether SAML requests are signed. TRUE: allows SAML requests to be signed. FALSE: does not allow SAML requests to be signed.",
	},
	"saml2_requested_nameid_format": {
		Type:             schema.TypeString,
		Optional:         true,
		Computed:         true,
		Description:      fmt.Sprintf("The SAML NameID format allows Snowflake to set an expectation of the identifying attribute of the user (i.e. SAML Subject) in the SAML assertion from the IdP to ensure a valid authentication to Snowflake. Valid options are: %v", sdk.AllSaml2SecurityIntegrationSaml2RequestedNameidFormats),
		ValidateDiagFunc: sdkValidation(sdk.ToSaml2SecurityIntegrationSaml2RequestedNameidFormatOption),
		DiffSuppressFunc: func(k, oldValue, newValue string, d *schema.ResourceData) bool {
			return strings.EqualFold(oldValue, newValue) || d.Get(k).(string) == string(sdk.Saml2SecurityIntegrationSaml2RequestedNameidFormatEmailAddress) && newValue == ""
		},
	},
	"saml2_post_logout_redirect_url": {
		Type:        schema.TypeString,
		Optional:    true,
		Description: "The endpoint to which Snowflake redirects users after clicking the Log Out button in the classic Snowflake web interface. Snowflake terminates the Snowflake session upon redirecting to the specified endpoint.",
	},
	"saml2_force_authn": {
		Type:        schema.TypeBool,
		Optional:    true,
		Description: "The Boolean indicating whether users, during the initial authentication flow, are forced to authenticate again to access Snowflake. When set to TRUE, Snowflake sets the ForceAuthn SAML parameter to TRUE in the outgoing request from Snowflake to the identity provider. TRUE: forces users to authenticate again to access Snowflake, even if a valid session with the identity provider exists. FALSE: does not force users to authenticate again to access Snowflake.",
	},
	"saml2_snowflake_issuer_url": {
		Type:        schema.TypeString,
		Optional:    true,
		Computed:    true,
		Description: "The string containing the EntityID / Issuer for the Snowflake service provider. If an incorrect value is specified, Snowflake returns an error message indicating the acceptable values to use.",
	},
	"saml2_snowflake_acs_url": {
		Type:        schema.TypeString,
		Optional:    true,
		Computed:    true,
		Description: "The string containing the Snowflake Assertion Consumer Service URL to which the IdP will send its SAML authentication response back to Snowflake. This property will be set in the SAML authentication request generated by Snowflake when initiating a SAML SSO operation with the IdP. If an incorrect value is specified, Snowflake returns an error message indicating the acceptable values to use.",
	},
	"saml2_snowflake_metadata": {
		Type:        schema.TypeString,
		Computed:    true,
		Description: "Metadata created by Snowflake to provide to SAML2 provider.",
	},
	"saml2_digest_methods_used": {
		Type:        schema.TypeString,
		Computed:    true,
		Description: "Digest methods used for this integration.",
	},
	"saml2_signature_methods_used": {
		Type:        schema.TypeString,
		Computed:    true,
		Description: "Signature methods used for this integration.",
	},
	"allowed_user_domains": {
		Type: schema.TypeList,
		Elem: &schema.Schema{
			Type: schema.TypeString,
		},
		Optional:    true,
		Description: "A list of email domains that can authenticate with a SAML2 security integration. If this field changes value from non-empty to empty, the whole resource is recreated because of Snowflake limitations.",
	},
	"allowed_email_patterns": {
		Type: schema.TypeList,
		Elem: &schema.Schema{
			Type: schema.TypeString,
		},
		Optional:    true,
		Description: "A list of regular expressions that email addresses are matched against to authenticate with a SAML2 security integration. If this field changes value from non-empty to empty, the whole resource is recreated because of Snowflake limitations.",
	},
	"comment": {
		Type:        schema.TypeString,
		Optional:    true,
		Description: "Specifies a comment for the integration.",
	},
	"created_on": {
		Type:        schema.TypeString,
		Computed:    true,
		Description: "Date and time when the SAML2 integration was created.",
	},
}

// SAML2Integration returns a pointer to the resource representing a SAML2 security integration.
func SAML2Integration() *schema.Resource {
	return &schema.Resource{
		CreateContext: CreateContextSAML2Integration,
		ReadContext:   ReadContextSAML2Integration,
		UpdateContext: UpdateContextSAML2Integration,
		DeleteContext: DeleteContextSAM2LIntegration,
		CustomizeDiff: customdiff.Sequence(
			ForceNewIfChangeToEmptySlice[any]("allowed_user_domains"),
			ForceNewIfChangeToEmptySlice[any]("allowed_email_patterns"),
			ForceNewIfChangeToEmptyString("saml2_sp_initiated_login_page_label"),
		),
		Schema: saml2IntegrationSchema,
		Importer: &schema.ResourceImporter{
			StateContext: schema.ImportStatePassthroughContext,
		},
	}
}

func CreateContextSAML2Integration(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
	client := meta.(*provider.Context).Client
	name := d.Get("name").(string)
	id := sdk.NewAccountObjectIdentifier(name)
	issuer := d.Get("saml2_issuer").(string)
	ssoUrl := d.Get("saml2_sso_url").(string)
	providerRaw := d.Get("saml2_provider").(string)
	cert := d.Get("saml2_x509_cert").(string)
	provider, err := sdk.ToSaml2SecurityIntegrationSaml2ProviderOption(providerRaw)
	if err != nil {
		return diag.FromErr(err)
	}
	req := sdk.NewCreateSaml2SecurityIntegrationRequest(id, issuer, ssoUrl, provider, cert)

	if !d.GetRawConfig().AsValueMap()["enabled"].IsNull() {
		req.WithEnabled(d.Get("enabled").(bool))
	}

	if v, ok := d.GetOk("saml2_sp_initiated_login_page_label"); ok {
		req.WithSaml2SpInitiatedLoginPageLabel(v.(string))
	}

	if !d.GetRawConfig().AsValueMap()["saml2_enable_sp_initiated"].IsNull() {
		req.WithSaml2EnableSpInitiated(d.Get("saml2_enable_sp_initiated").(bool))
	}

	if v, ok := d.GetOk("saml2_snowflake_x509_cert"); ok {
		req.WithSaml2SnowflakeX509Cert(v.(string))
	}

	if !d.GetRawConfig().AsValueMap()["saml2_sign_request"].IsNull() {
		req.WithSaml2SignRequest(d.Get("saml2_sign_request").(bool))
	}

	if v, ok := d.GetOk("saml2_requested_nameid_format"); ok {
		formatRaw := v.(string)
		format, err := sdk.ToSaml2SecurityIntegrationSaml2RequestedNameidFormatOption(formatRaw)
		if err != nil {
			return diag.FromErr(err)
		}
		req.WithSaml2RequestedNameidFormat(format)
	}

	if v, ok := d.GetOk("saml2_post_logout_redirect_url"); ok {
		req.WithSaml2PostLogoutRedirectUrl(v.(string))
	}

	if !d.GetRawConfig().AsValueMap()["saml2_force_authn"].IsNull() {
		req.WithSaml2ForceAuthn(d.Get("saml2_force_authn").(bool))
	}

	if v, ok := d.GetOk("saml2_snowflake_issuer_url"); ok {
		req.WithSaml2SnowflakeIssuerUrl(v.(string))
	}

	if v, ok := d.GetOk("saml2_snowflake_acs_url"); ok {
		req.WithSaml2SnowflakeAcsUrl(v.(string))
	}

	if v, ok := d.GetOk("allowed_user_domains"); ok {
		stringAllowedUserDomains := expandStringList(v.([]any))
		allowedUserDomains := make([]sdk.UserDomain, len(stringAllowedUserDomains))
		for i, v := range stringAllowedUserDomains {
			allowedUserDomains[i] = sdk.UserDomain{
				Domain: v,
			}
		}
		req.WithAllowedUserDomains(allowedUserDomains)
	}

	if v, ok := d.GetOk("allowed_email_patterns"); ok {
		stringAllowedEmailPatterns := expandStringList(v.([]any))
		allowedEmailPatterns := make([]sdk.EmailPattern, len(stringAllowedEmailPatterns))
		for i, v := range stringAllowedEmailPatterns {
			allowedEmailPatterns[i] = sdk.EmailPattern{
				Pattern: v,
			}
		}
		req.WithAllowedEmailPatterns(allowedEmailPatterns)
	}

	if v, ok := d.GetOk("comment"); ok {
		req.WithComment(v.(string))
	}

	if err := client.SecurityIntegrations.CreateSaml2(ctx, req); err != nil {
		return diag.FromErr(err)
	}

	d.SetId(name)

	return ReadContextSAML2Integration(ctx, d, meta)
}

func ReadContextSAML2Integration(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
	client := meta.(*provider.Context).Client
	id := helpers.DecodeSnowflakeID(d.Id()).(sdk.AccountObjectIdentifier)

	integration, err := client.SecurityIntegrations.ShowByID(ctx, id)
	if err != nil {
		if errors.Is(err, sdk.ErrObjectNotFound) {
			d.SetId("")
			return diag.Diagnostics{
				diag.Diagnostic{
					Severity: diag.Warning,
					Summary:  "Failed to query security integration. Marking the resource as removed.",
					Detail:   fmt.Sprintf("Security integration name: %s, Err: %s", id.FullyQualifiedName(), err),
				},
			}
		}
		return diag.FromErr(err)
	}

	if c := integration.Category; c != sdk.SecurityIntegrationCategory {
		return diag.FromErr(fmt.Errorf("expected %v to be a %s integration, got %v", id, sdk.SecurityIntegrationCategory, c))
	}

	if err := d.Set("name", integration.Name); err != nil {
		return diag.FromErr(err)
	}

	if err := d.Set("comment", integration.Comment); err != nil {
		return diag.FromErr(err)
	}

	if err := d.Set("created_on", integration.CreatedOn.String()); err != nil {
		return diag.FromErr(err)
	}

	if err := d.Set("enabled", integration.Enabled); err != nil {
		return diag.FromErr(err)
	}

	integrationProperties, err := client.SecurityIntegrations.Describe(ctx, id)
	if err != nil {
		return diag.FromErr(err)
	}
	for _, property := range integrationProperties {
		name := property.Name
		value := property.Value
		switch name {
		case "ENABLED", "COMMENT":
			// set using the SHOW INTEGRATION, ignoring here
		case "SAML2_ISSUER":
			if err := d.Set("saml2_issuer", value); err != nil {
				return diag.FromErr(err)
			}
		case "SAML2_SSO_URL":
			if err := d.Set("saml2_sso_url", value); err != nil {
				return diag.FromErr(err)
			}
		case "SAML2_PROVIDER":
			if err := d.Set("saml2_provider", value); err != nil {
				return diag.FromErr(err)
			}
		case "SAML2_X509_CERT":
			if err := d.Set("saml2_x509_cert", value); err != nil {
				return diag.FromErr(err)
			}
		case "SAML2_SP_INITIATED_LOGIN_PAGE_LABEL":
			if err := d.Set("saml2_sp_initiated_login_page_label", value); err != nil {
				return diag.FromErr(err)
			}
		case "SAML2_ENABLE_SP_INITIATED":
			if err := d.Set("saml2_enable_sp_initiated", helpers.StringToBool(value)); err != nil {
				return diag.FromErr(err)
			}
		case "SAML2_SNOWFLAKE_X509_CERT":
			if err := d.Set("saml2_snowflake_x509_cert", value); err != nil {
				return diag.FromErr(err)
			}
		case "SAML2_SIGN_REQUEST":
			if err := d.Set("saml2_sign_request", helpers.StringToBool(value)); err != nil {
				return diag.FromErr(err)
			}
		case "SAML2_REQUESTED_NAMEID_FORMAT":
			if err := d.Set("saml2_requested_nameid_format", value); err != nil {
				return diag.FromErr(err)
			}
		case "SAML2_POST_LOGOUT_REDIRECT_URL":
			if err := d.Set("saml2_post_logout_redirect_url", value); err != nil {
				return diag.FromErr(err)
			}
		case "SAML2_FORCE_AUTHN":
			if err := d.Set("saml2_force_authn", helpers.StringToBool(value)); err != nil {
				return diag.FromErr(err)
			}
		case "SAML2_SNOWFLAKE_ISSUER_URL":
			if err := d.Set("saml2_snowflake_issuer_url", value); err != nil {
				return diag.FromErr(err)
			}
		case "SAML2_SNOWFLAKE_ACS_URL":
			if err := d.Set("saml2_snowflake_acs_url", value); err != nil {
				return diag.FromErr(err)
			}
		case "SAML2_SNOWFLAKE_METADATA":
			if err := d.Set("saml2_snowflake_metadata", value); err != nil {
				return diag.FromErr(err)
			}
		case "SAML2_DIGEST_METHODS_USED":
			if err := d.Set("saml2_digest_methods_used", value); err != nil {
				return diag.FromErr(err)
			}
		case "SAML2_SIGNATURE_METHODS_USED":
			if err := d.Set("saml2_signature_methods_used", value); err != nil {
				return diag.FromErr(err)
			}
		case "ALLOWED_USER_DOMAINS":
			value = strings.TrimLeft(value, "[")
			value = strings.TrimRight(value, "]")
			elems := strings.Split(value, ",")
			if value == "" {
				elems = nil
			}
			if err := d.Set("allowed_user_domains", elems); err != nil {
				return diag.FromErr(err)
			}
		case "ALLOWED_EMAIL_PATTERNS":
			value = strings.TrimLeft(value, "[")
			value = strings.TrimRight(value, "]")
			elems := strings.Split(value, ",")
			if value == "" {
				elems = nil
			}
			if err := d.Set("allowed_email_patterns", elems); err != nil {
				return diag.FromErr(err)
			}
		default:
			log.Printf("[WARN] unexpected property %v returned from Snowflake", name)
		}
	}

	return nil
}

func UpdateContextSAML2Integration(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
	client := meta.(*provider.Context).Client
	id := helpers.DecodeSnowflakeID(d.Id()).(sdk.AccountObjectIdentifier)
	set, unset := sdk.NewSaml2IntegrationSetRequest(), sdk.NewSaml2IntegrationUnsetRequest()

	if d.HasChange("enabled") {
		set.WithEnabled(d.Get("enabled").(bool))
	}

	if d.HasChange("saml2_issuer") {
		set.WithSaml2Issuer(d.Get("saml2_issuer").(string))
	}

	if d.HasChange("saml2_sso_url") {
		set.WithSaml2SsoUrl(d.Get("saml2_sso_url").(string))
	}

	if d.HasChange("saml2_provider") {
		valueRaw := d.Get("saml2_provider").(string)
		value, err := sdk.ToSaml2SecurityIntegrationSaml2ProviderOption(valueRaw)
		if err != nil {
			return diag.FromErr(err)
		}
		set.WithSaml2Provider(value)
	}

	if d.HasChange("saml2_x509_cert") {
		set.WithSaml2X509Cert(d.Get("saml2_x509_cert").(string))
	}

	if d.HasChange("saml2_sp_initiated_login_page_label") {
		set.WithSaml2SpInitiatedLoginPageLabel(d.Get("saml2_sp_initiated_login_page_label").(string))
	}

	if d.HasChange("saml2_enable_sp_initiated") {
		set.WithSaml2EnableSpInitiated(d.Get("saml2_enable_sp_initiated").(bool))
	}

	if d.HasChange("saml2_snowflake_x509_cert") {
		set.WithSaml2SnowflakeX509Cert(d.Get("saml2_snowflake_x509_cert").(string))
	}

	if d.HasChange("saml2_sign_request") {
		set.WithSaml2SignRequest(d.Get("saml2_sign_request").(bool))
	}

	if d.HasChange("saml2_requested_nameid_format") {
		v := d.Get("saml2_requested_nameid_format").(string)
		if len(v) > 0 {
			value, err := sdk.ToSaml2SecurityIntegrationSaml2RequestedNameidFormatOption(v)
			if err != nil {
				return diag.FromErr(err)
			}
			set.WithSaml2RequestedNameidFormat(value)
		} else {
			unset.WithSaml2RequestedNameidFormat(true)
		}
	}

	if d.HasChange("saml2_post_logout_redirect_url") {
		v := d.Get("saml2_post_logout_redirect_url").(string)
		if len(v) > 0 {
			set.WithSaml2PostLogoutRedirectUrl(v)
		} else {
			unset.WithSaml2PostLogoutRedirectUrl(true)
		}
	}

	if d.HasChange("saml2_force_authn") {
		set.WithSaml2ForceAuthn(d.Get("saml2_force_authn").(bool))
	}

	if d.HasChange("saml2_snowflake_issuer_url") {
		set.WithSaml2SnowflakeIssuerUrl(d.Get("saml2_snowflake_issuer_url").(string))
	}

	if d.HasChange("saml2_snowflake_acs_url") {
		set.WithSaml2SnowflakeAcsUrl(d.Get("saml2_snowflake_acs_url").(string))
	}

	if d.HasChange("allowed_user_domains") {
		v := d.Get("allowed_user_domains").([]any)
		userDomains := make([]sdk.UserDomain, len(v))
		for i := range v {
			userDomains[i] = sdk.UserDomain{
				Domain: v[i].(string),
			}
		}
		set.WithAllowedUserDomains(userDomains)
	}

	if d.HasChange("allowed_email_patterns") {
		v := d.Get("allowed_email_patterns").([]any)
		emailPatterns := make([]sdk.EmailPattern, len(v))
		for i := range v {
			emailPatterns[i] = sdk.EmailPattern{
				Pattern: v[i].(string),
			}
		}
		set.WithAllowedEmailPatterns(emailPatterns)
	}

	if d.HasChange("comment") {
		if v := d.Get("comment").(string); len(v) > 0 {
			set.WithComment(v)
		} else {
			unset.WithComment(true)
		}
	}
	if !reflect.DeepEqual(*set, sdk.Saml2IntegrationSetRequest{}) {
		if err := client.SecurityIntegrations.AlterSaml2(ctx, sdk.NewAlterSaml2SecurityIntegrationRequest(id).WithSet(*set)); err != nil {
			return diag.FromErr(err)
		}
	}
	if (*unset != sdk.Saml2IntegrationUnsetRequest{}) {
		if err := client.SecurityIntegrations.AlterSaml2(ctx, sdk.NewAlterSaml2SecurityIntegrationRequest(id).WithUnset(*unset)); err != nil {
			return diag.FromErr(err)
		}
	}
	return ReadContextSAML2Integration(ctx, d, meta)
}

func DeleteContextSAM2LIntegration(ctx context.Context, d *schema.ResourceData, meta interface{}) diag.Diagnostics {
	id := helpers.DecodeSnowflakeID(d.Id()).(sdk.AccountObjectIdentifier)
	client := meta.(*provider.Context).Client

	err := client.SecurityIntegrations.Drop(ctx, sdk.NewDropSecurityIntegrationRequest(sdk.NewAccountObjectIdentifier(id.Name())).WithIfExists(true))
	if err != nil {
		return diag.Diagnostics{
			diag.Diagnostic{
				Severity: diag.Error,
				Summary:  "Error deleting integration",
				Detail:   fmt.Sprintf("id %v err = %v", id.Name(), err),
			},
		}
	}

	d.SetId("")
	return nil
}
