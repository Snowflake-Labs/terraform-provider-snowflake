package main

import (
	"bytes"
	"encoding/json"
	"flag"
	"fmt"
	"go/format"
	"io"
	"log"
	"os"
	"path/filepath"
	"strings"
)

var (
	blueprintPath     = flag.String("blueprint", "", ".json file containing blueprint for generation; must be set")
	lintIgnoreComment = "//lint:ignore U1000 This is used in the ddl tag"
)

func main() {
	fmt.Printf("Running generator on %s with args %#v\n", os.Getenv("GOFILE"), os.Args[1:])

	blueprint := loadBlueprint()
	fmt.Printf("Loaded blueprint %#v.\n", blueprint)

	gen := setUpGenerator(blueprint)
	fmt.Printf("Generator set up for package \"%s\" with output name \"%s\".\n", gen.outputPackage, gen.outputName)

	gen.addFilePreamble()
	gen.generateCreate()

	src, errSrcFormat := format.Source(gen.Buffer.Bytes())
	if errSrcFormat != nil {
		log.Panicln(errSrcFormat)
	}
	if err := os.WriteFile(gen.outputName, src, 0644); err != nil {
		log.Panicln(err)
	}
}

func loadBlueprint() *Blueprint {
	flag.Parse()

	if len(*blueprintPath) == 0 {
		flag.Usage()
		log.Panicln("Blueprint .json file was not specified.")
	}

	blueprintFile, errOpenFile := os.Open(*blueprintPath)
	if errOpenFile != nil {
		log.Panicln(errOpenFile)
	}
	defer blueprintFile.Close()
	fmt.Printf("Opened blueprint file %s\n", blueprintFile.Name())

	byteValue, errReadBytes := io.ReadAll(blueprintFile)
	if errReadBytes != nil {
		log.Panicln(errReadBytes)
	}

	var blueprint Blueprint
	if err := json.Unmarshal(byteValue, &blueprint); err != nil {
		log.Panicln(err)
	}
	return &blueprint
}

type Blueprint struct {
	Object Object `json:"object"`
	Create Create `json:"create"`
}

type Object struct {
	Name string `json:"name"`
}

type Create struct {
	Docs      string          `json:"docs"`
	Modifiers CreateModifiers `json:"modifiers"`
	Fields    []CreateField   `json:"fields"`
}

type CreateModifiers struct {
	OrReplace   bool `json:"orReplace"`
	IfNotExists bool `json:"ifNotExists"`
}

type CreateField struct {
	Name       string        `json:"name"`
	Type       string        `json:"type"`
	Quotations string        `json:"quotations"`
	Fields     []CreateField `json:"fields"`
}

func setUpGenerator(blueprint *Blueprint) *Generator {
	wd, errWd := os.Getwd()
	if errWd != nil {
		log.Panicln(errWd)
	}

	file := os.Getenv("GOFILE")
	fileWithoutSuffix, _ := strings.CutSuffix(file, ".go")
	baseName := fmt.Sprintf("%s_generated.go", fileWithoutSuffix)
	outputName := filepath.Join(wd, baseName)

	return &Generator{
		Buffer:        bytes.Buffer{},
		blueprint:     blueprint,
		outputPackage: os.Getenv("GOPACKAGE"),
		outputName:    outputName,
	}
}

type Generator struct {
	Buffer              bytes.Buffer
	helperStringBuilder strings.Builder
	blueprint           *Blueprint
	outputPackage       string
	outputName          string
}

func (gen *Generator) printf(format string, args ...any) {
	printf(&gen.Buffer, format, args...)
}

func printf(w io.Writer, format string, args ...any) {
	_, err := fmt.Fprintf(w, format, args...)
	if err != nil {
		log.Panicln(err)
	}
}

func (gen *Generator) addFilePreamble() {
	gen.printf("// Code generated by blueprint generator; DO NOT EDIT.\n")
	gen.printf("\n")
	gen.printf("package %s\n", gen.outputPackage)
	gen.printf("\n")
}

// TODO: implement using go text/template or at least clean it
// TODO: pick identifier type programmatically instead of hardcoded SchemaObjectIdentifier
// TODO: add possibility to declare field as required or not
// TODO: field names to CamelCase
// TODO: handle additional structs better
func (gen *Generator) generateCreate() {
	gen.printf("// Based on %s\n", gen.blueprint.Create.Docs)
	gen.printf("type %sCreateOptionsGen struct {\n", strings.Title(gen.blueprint.Object.Name))

	// create section is almost the same everytime
	gen.printf("create bool `ddl:\"static\" sql:\"CREATE\"` %s\n", lintIgnoreComment)
	if gen.blueprint.Create.Modifiers.OrReplace {
		gen.printf("orReplace *bool `ddl:\"keyword\" sql:\"OR REPLACE\"` \n")
	}
	gen.printf("%s bool `ddl:\"static\" sql:\"%s\"` %s\n", gen.blueprint.Object.Name, strings.ToUpper(gen.blueprint.Object.Name), lintIgnoreComment)
	if gen.blueprint.Create.Modifiers.IfNotExists {
		gen.printf("ifNotExists *bool `ddl:\"keyword\" sql:\"IF NOT EXISTS\"` \n")
	}
	gen.printf("name SchemaObjectIdentifier `ddl:\"identifier\"` \n")
	gen.printf("\n")

	// fields
	var additionalStructs = gen.generateFields(gen.blueprint.Create.Fields)

	gen.printf("}\n")
	gen.printf("\n")

	for _, a := range additionalStructs {
		gen.printf(a.String())
	}
}

func (gen *Generator) generateFields(fields []CreateField) []strings.Builder {
	return generateFields(&gen.Buffer, fields)
}

func generateFields(w io.Writer, fields []CreateField) []strings.Builder {
	var additionalStructs []strings.Builder
	for _, field := range fields {
		switch t := field.Type; t {
		case "string", "bool":
			printf(w, "%s *%s `ddl:\"parameter,%s\" sql:\"%s\"` \n", strings.ToLower(field.Name), t, field.Quotations, field.Name)
			break
		case "complex":
			printf(w, "\n%s %s `ddl:\"static\" sql:\"%s\"` \n", strings.ToLower(field.Name), strings.ToLower(field.Name), field.Name)
			var sb strings.Builder
			generateStruct(&sb, strings.ToLower(field.Name), field.Fields)
			additionalStructs = append(additionalStructs, sb)
			break
		case "keyword":
			printf(w, "%s string `ddl:\"keyword,%s\"` \n", strings.ToLower(field.Name), field.Quotations)
			break
		default:
			log.Panicf("Field type %s is not supported.\n", t)
		}
	}
	return additionalStructs
}

func generateStruct(str *strings.Builder, name string, fields []CreateField) {
	printf(str, "type %s struct {\n", name)

	generateFields(str, fields)

	printf(str, "}\n")
	printf(str, "\n")
}
